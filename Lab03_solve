class studentcode extends mazedfs
{
    public studentcode(int bh0, int mh0, int mw0) // don't change constructor
    { 
	super(bh0,mh0,mw0); 
    } 

public void digout(int y, int x)   // modify this function
{
     // solution

     M[y][x] = 1;  // digout maze at coordinate y,x
     drawblock(y,x);  // change graphical display to reflect space dug out
     //     delay(40); // slows animation

     // order directions in terms of North, East, South, West
     int[] DX = {0,1,0,-1};
     int[] DY = {-1,0,1,0};
     // randomly scramble DX, DY:
     for(int i=0;i<DX.length-1;i++)
	 {
	     int r = i+(int)(Math.random()*(DX.length-i));
	     int tmp = DX[i];  DX[i]=DX[r];  DX[r]=tmp;
	     tmp = DY[i]; DY[i] = DY[r]; DY[r]=tmp;
	 }
     
     for (int dir = 0;dir<DX.length;dir++)
	 {
	     int dx = DX[dir], dy = DY[dir];
	     // look two spaces ahead
	     int nx = x + 2*dx, ny = y+ 2*dy;
	     if (nx>=0 && nx<mw && ny>=0 && ny<mh && M[ny][nx]==0)
		 {
		     // digout itermediate square:
		     M[y+dy][x+dx] = 1;
		     drawblock(y+dy,x+dx);
		     // recursively dig out two spots ahead in chosen dir:
		     digout(ny,nx);
		 }
	 }// for each dir
 }//digout

 public void solve()
 {
	int x=1, y=1;
	
	byte[] Vals = new byte[4];
	
	
	delay(40);
	drawdot(y, x);
	while( y != mh-2 || x != mw-2)
	{
		
		drawblock(y, x);
		
		if (y-1 >= 0 && M[y-1][x] != 0) Vals[0] = M[y-1][x];
		else Vals[0] = 127;
		if (x-1 >= 0 && M[y][x-1] != 0) Vals[1] = M[y][x-1];
		else Vals[1] = 127;
		if (y+1 <= 41 && M[y+1][x] != 0) Vals[2] = M[y+1][x];
		else Vals[2] = 127;
		if (x+1 <= 51 && M[y][x+1] != 0) Vals[3] = M[y][x+1];
		else Vals[3] = 127;
		
		int direction = 0;
		for (int four = 0; four < Vals.length; four++)
		{
			if (Vals[direction] > Vals[direction+1])
				direction = direction + 1;
		}
		
		if (direction == 0 && y-1 != mh-2)
		{
			y -= 1;
			drawdot(y, x);
			M[y][x] += 1;
		}		
		else direction += 1;
		
		if (direction == 1 && x-1 != mw-2)
		{
			x -= 1;
			drawdot(y, x);
			M[y][x] += 1;
		}
		else direction += 1;

		if (direction == 2 && y+1 != mh-2)
		{
			y += 1;
			drawdot(y, x);
			M[y][x] += 1;
		}
		else direction += 1;

		if (direction == 3 && x+1 != mw-2)
		{
			x += 1;
			drawdot(y, x);
			M[y][x] += 1;		
		}
		else direction += 1;


		
	} 
 }

}//studentcode subclass
